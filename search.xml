<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Object Oriented Programming</title>
    <url>/2021/01/23/oop/</url>
    <content><![CDATA[<p>미리 말하지만 나는 객체지향을 싫어한다. 왜냐면 공부하면 할수록 더 좋은 패러다임이 많고 이에 동의하는 사람들이 존재하기 때문이다.</p>
<a id="more"></a>

<blockquote>
<p>객체 지향 프로그래밍은 캘리포니아에서만 나올 수 있는 것 중 이례적으로 나쁜 아이디어입니다.<br>(Object-oriented programming is an exceptionally bad idea which could only have originated in California.)<br>— Edsger W. Dijkstra</p>
</blockquote>
<p>그럼에도 불구하고 객체지향을 모르는 것은 허용하고 싶지 않다.</p>
<p>어떠한 언어는 객체지향을 기본 패러다임으로 만들어진 언어도 있고 (자바나.. C#같은…)<br>의도하지 않더라도 현실과 많이 닮은 점들이 있기 때문에 코드를 짜다보면 자연스럽게 객체를 짜고있기 때문이다.</p>
<p>자바스크립트 세계관에서는 객체지향이 어떻게 사용되는지 알아보자</p>
<h2 id="객체-Object"><a href="#객체-Object" class="headerlink" title="객체 (Object)"></a>객체 (Object)</h2><p>객체는 무엇인가. 현실의 어떠한 물체를 생각해보자<br>현실의 어떠한 물체는 속성이 있고. 기능이 있다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">무게는 100g 정도 됩니다.</span><br><span class="line">색상은 은색입니다.</span><br><span class="line">소재는 철과 나무입니다.</span><br><span class="line">모양은 대체로 길고 뾰족한 모양입니다.</span><br><span class="line">손잡이를 가지고 있습니다.</span><br><span class="line">이름은 식칼이라고 부릅니다.</span><br></pre></td></tr></table></figure>
<p>이것은 속성이다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">벨 수 있습니다.</span><br><span class="line">찌를 수 있습니다.</span><br><span class="line">자를 수 있습니다.</span><br><span class="line">손잡이를 이용하여 누를 수 있습니다.</span><br></pre></td></tr></table></figure>
<p>이것은 기능이다.<br>말 그대로 객체는 속성과 기능을 가진 현실의 어떠한 물체를 본따서 컴퓨터에서 사용하려는 것이고, 이렇게 만들어진 것이 Object 인 것이다.</p>
<h2 id="객체지향"><a href="#객체지향" class="headerlink" title="객체지향"></a>객체지향</h2><p>앞서 설명한 Object를 만들었다면 이러한 Object를 적극 활용하여 프로그래밍을 하자는 패러다임..<br>객체지향에서는 이 객체를 적극적으로 활용하기 위하여 몇가지 객체의 특징들을 약속해놓았다.</p>
<h3 id="객체지향의-특징"><a href="#객체지향의-특징" class="headerlink" title="객체지향의 특징"></a>객체지향의 특징</h3><p>캡슐화 (Encapsulation)<br>추상화 (Abstraction)<br>상속 (Inheritance)<br>다형성 (Polymorphism)</p>
<h4 id="캡슐화-Encapsulation"><a href="#캡슐화-Encapsulation" class="headerlink" title="캡슐화 (Encapsulation)"></a>캡슐화 (Encapsulation)</h4><p>캡슐화하는 이유는 두가지다.</p>
<p>편의적인 면<br>보안적인 면<br>자 아무것도 없는 도마위에 원산지 라고만 쓰여있다.<br>이러면 당연히 무엇의 원산지인지 모르지 않을까?<br>그런데 식칼에 “원산지” 라고 쓰여있다.<br>식칼의 원산지일 것이라고 사람들은 연상하게 된다.<br>그래서 우리는 프로그래밍에서도 도마위에 식칼의원산지, 생선의원산지, 이런식으로 일일히 나열하는 것이 아닌.<br>생선을 만들고 그 안에 속성으로 원산지를 넣어주고,<br>식칼을 만들고 그 안에 속성으로 원산지를 넣어주어 캡슐화시킨다.<br>편리하지 않은가</p>
<p>그렇다면 보안적인 면은 어떨까?<br>이것이 정확히 몇%의 합금인지 남들에게 알리고 싶지 않다면, 사실 이것을 남들에게 상해를 입힐 수 있는 기능도 있다는 것을 알리고 싶지 않다면?<br>이것을 숨기고 그냥 난 식칼이야 요리할때 써. 라고 건네주는 것만으로도 충분히 이 Object의 역할은 달성하지 않았을까<br>Object 의 숨기고 싶은 면, 혹은 굳이 안보여 줘도 되는 면들을 캡슐화를 통해 숨길 수 있다</p>
<h4 id="추상화-abstraction"><a href="#추상화-abstraction" class="headerlink" title="추상화 (abstraction)"></a>추상화 (abstraction)</h4><p>객체에게 부탁한다. 이것좀 건네줘.<br>그런데 사실 이 건네준다는 게 엄청나게 복잡하다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">이두근을 이완시켜 펼치고.</span><br><span class="line">다섯손가락 두번째마디들을 굽혀서 0.7J의 힘으로 누른 뒤</span><br><span class="line">다시 이두근을 45 수축 시킨뒤 상체를 돌려 나를 바라봐.</span><br><span class="line">그 이후 손을 펴서 나에게 건내줘.</span><br><span class="line">더 쪼갤 수 있는데 그만 쪼개겠다.</span><br><span class="line">하고싶은 말은 이것이다. 여기서 중요한 부분만을 추려낸다.</span><br><span class="line">물건을 들고, 나를보고, 건내줘.</span><br></pre></td></tr></table></figure>
<p>물건또한 마찬가지겠지.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">사과가 대체로 빨갛지만. 사실은 상단부분은 체리애플블라썸 색이고, 중단부분은 베리베리스트로베리 색이고 하단부분은 로열레드 색이다.</span><br><span class="line">근데 그냥 빨갛다고 부르겠다.</span><br></pre></td></tr></table></figure>
<p>자 이게 추상화다. 일련의 복잡한 과정, 속성들을 축약하고, 간소화시키는 것.<br>이러한 추상화가 깊어질수록 우리는 이 복잡한 것을 간단하게 볼 수 있게 된다.</p>
<h4 id="상속-Inheritance"><a href="#상속-Inheritance" class="headerlink" title="상속 (Inheritance)"></a>상속 (Inheritance)</h4><p>상속은 생각보다 간단하다. 상속은 특히 웃긴게 무수히 많은 상속이 가능하다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">동물이 있다. 동물은 보통 이름이 있고, 생명활동을 한다.</span><br><span class="line">해양동물이 있다. 해양동물은 동물의 속성과 기능을 모두 갖고 있으며, 서식지가 바다이다</span><br><span class="line">갑각류가 있다. 갑각류는 해양동물의 속성과 기능을 모두 갖고 있으며, 피부가 단단하다.</span><br><span class="line">어류가 있다. 어류는 해양동물의 속성과 기능을 모두 갖고 있으며, 아가미로 호흡한다.</span><br><span class="line">참치가 있다. 참치는 어류의 속성과 기능을 모두 갖고 있으며, 지방질이 풍부하고 깊은곳에 서식한다.</span><br></pre></td></tr></table></figure>
<p>정리해보자. 동물 &gt; 해양동물 &gt; 어류 &gt; 참치<br>여기서 화살표가 상속 이다.<br>부모의 속성과 기능이 자식에도 존재한다.<br>주의해야 할점은. 부모가 자식때문에 필요없는 속성을 갖고 있지 않게 표현해야 하고.<br>상속하지 않고 같은 부모를 사용해야 할 때를 구분하는 것이다.<br>여기서는 갑각류와 어류같이 해양생물 정도만 공통적이고 나머지는 차이가 존재하기 때문에 추가 상속하지 않았다.</p>
<h4 id="다형성-Polymophism"><a href="#다형성-Polymophism" class="headerlink" title="다형성 (Polymophism)"></a>다형성 (Polymophism)</h4><p>사람이라는 Object가 있다. 이 사람은 동물을 상속받았다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">사람.인사해()</span><br><span class="line">헬로</span><br></pre></td></tr></table></figure>
<p>예측된 결과다. 그럼 이번엔 개에게 시키겠다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">개.인사해()</span><br><span class="line">헬로</span><br></pre></td></tr></table></figure>
<p>응? 이러한 일이 발생하지 않게 같은 이름의 기능이라도 다르게 작동시킬 수 있게 해주는 특징이 다형성이다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">개.인사해()</span><br><span class="line">멍</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">고양이.인사해()</span><br><span class="line">야옹</span><br></pre></td></tr></table></figure>
<p>다형성이 있어야 이러한 편리한 기능이 구현된다. 자바에서는 이를 구현하는 오버로딩과 오버라이딩이라는 방법이 있는데<br>여기서는 언급하지 않겠다.</p>
<h2 id="인스턴스"><a href="#인스턴스" class="headerlink" title="인스턴스"></a>인스턴스</h2><p>자바에서는 클래스라는게 있다.</p>
<p>클래스는 공장에서 물건을 찍어내는 틀, 사진을 찍어내는 청사진과 같다.<br>우리가 식칼을 만들려고 한다. 그때마다 위에서 설명 한 속성과 기능들을 나열해야 한다면?</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">무게는 100g 정도 됩니다.</span><br><span class="line">색상은 은색입니다.</span><br><span class="line">소재는 철과 나무입니다.</span><br><span class="line">모양은 대체로 길고 뾰족한 모양입니다.</span><br><span class="line">손잡이를 가지고 있습니다.</span><br><span class="line">이름은 식칼이라고 부릅니다.</span><br><span class="line">벨 수 있습니다.</span><br><span class="line">찌를 수 있습니다.</span><br><span class="line">자를 수 있습니다.</span><br><span class="line">손잡이를 이용하여 누를 수 있습니다.</span><br></pre></td></tr></table></figure>
<p>이런 물체를 만들어줘. 매번 이렇게 부탁할것인가?<br>자 이렇게 해보자<br>앞으로 내가 식칼클래스를 쓰면 항상 위에 나열한 속성과 기능이 담겨있어야 해.</p>
<p>자 그럼 사용해보자</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">식칼클래스로 식칼을 만들어줘.</span><br></pre></td></tr></table></figure>
<p>여기서 만들어진 식칼이 인스턴스 라는거다.<br>즉 한개의 클래스로 많은 인스턴스를 만들수 있다.</p>
<p>그러면 자바스크립트에서는??</p>
<p>자바스크립트에서는 클래스가 아니라 함수로 인스턴스를 만든다</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure>
<p>함수를 실행했는데 인스턴스가 만들어졌다. 어떻게?<br>여기서 사용되는 게 prototype 이다 알아보자.</p>
<h2 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h2><p>자바스크립트 객체는 Prototype이라는 내부 프로퍼티가 존재한다.<br>prototype은 본인이 원래 가져야할 속성과 기능의 명세. 즉 클래스와 같은 역할을 하고 있다.</p>
<p>객체를 생성하면 자신이 상속받은 부모의 prototype은 <code>__proto__</code> 속성에 연결한다.<br>이를 통해 자바스크립트의 모든 객체는 자신의 부모 역할을 담당하는 객체와 연결되어 있다.<br>이것은 <strong>프로토타입</strong> 링크 라고 하겠다.<br>특정 객체의 프로퍼티나 메소드에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티 또는 메소드가 없다면<br><code>__proto__</code>이 가리키는 링크를 따라 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티나 메소드를 차례대로 검색한다.<br>이것을 <strong>프로토타입 체인</strong>이라 한다.</p>
<p>자 이건 알겠고 그렇다면 함수는?</p>
<p>함수를 정의하면 함수만 생성되는 것이 아니라 Prototype Object도 같이 생성이 된다.<br>Prototype Object는 <code>constructor</code>와 <code>__proto__</code>를 가지고 있다.<br>constructor는 함수인데. 이 함수는 만들어질 객체가 가져야할 property들이 정의되어 있다.<br>new 키워드와 함께 함수를 호출할 경우 constructor함수를 실행하고 <code>__proto__</code> 를 부모의prototype과 연결한다.<br>new로써 만들어진 모든 객체는 결국 부모.prototype 과 <code>__proto__</code> 링크로 연결된다는 것이다.</p>
<p>결과적으로 이렇게 된다.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">instance.__proto__ === <span class="built_in">Object</span>.prototype</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="인스턴스를-만드는-방법-실습"><a href="#인스턴스를-만드는-방법-실습" class="headerlink" title="인스턴스를 만드는 방법 실습"></a>인스턴스를 만드는 방법 실습</h3><h4 id="functional"><a href="#functional" class="headerlink" title="functional"></a>functional</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Human = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instance = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  instance.name = <span class="string">&#x27;functional instantiation&#x27;</span>;</span><br><span class="line">  instance.func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;기능입니다.&quot;</span>)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = Human();</span><br><span class="line"></span><br><span class="line">instance.name;</span><br><span class="line"><span class="comment">// functional instantiation</span></span><br><span class="line"></span><br><span class="line">instance.func();</span><br><span class="line"><span class="comment">// 기능입니다.</span></span><br><span class="line">functional shared</span><br><span class="line"><span class="keyword">const</span> extend = <span class="function"><span class="keyword">function</span>(<span class="params">to, <span class="keyword">from</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> <span class="keyword">from</span>) &#123;</span><br><span class="line">    to[key] = <span class="keyword">from</span>[key];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sharedFunc = &#123;&#125;;</span><br><span class="line">sharedFunc.say = <span class="function"><span class="keyword">function</span>(<span class="params">hi</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.say = hi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Human = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instance = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  instance.name = <span class="string">&#x27;functional shared instantiation&#x27;</span>;</span><br><span class="line">  instance.func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;기능입니다.&quot;</span>)</span><br><span class="line">  &#125;;</span><br><span class="line">  extend(instance, sharedFunc);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> instance = Human();</span><br><span class="line"></span><br><span class="line">instance.name;</span><br><span class="line"><span class="comment">// functional shared instantiation</span></span><br><span class="line"></span><br><span class="line">instance.func();</span><br><span class="line"><span class="comment">// 기능입니다.</span></span><br><span class="line"></span><br><span class="line">instance.say(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">instance.say;</span><br><span class="line"><span class="comment">// hello</span></span><br></pre></td></tr></table></figure>
<h4 id="prototypal"><a href="#prototypal" class="headerlink" title="prototypal"></a>prototypal</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> method = &#123;&#125;;</span><br><span class="line"> method.say = <span class="function"><span class="keyword">function</span>(<span class="params">hi</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.say = hi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Human = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instance = <span class="built_in">Object</span>.create(method);</span><br><span class="line"></span><br><span class="line">  instance.name = <span class="string">&#x27;prototypal instantiation&#x27;</span>;</span><br><span class="line">  instance.func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;기능입니다.&quot;</span>)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = Human();</span><br><span class="line"></span><br><span class="line">instance.name;</span><br><span class="line"><span class="comment">// prototypal instantiation</span></span><br></pre></td></tr></table></figure>
<h4 id="PseudoClassical"><a href="#PseudoClassical" class="headerlink" title="PseudoClassical"></a>PseudoClassical</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Human = <span class="function"><span class="keyword">function</span>(<span class="params">hi</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.say = hi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Human.prototype.bye = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;bye bye&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> Human(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">instance.say;</span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"></span><br><span class="line">instance.bye();</span><br><span class="line"><span class="comment">// bye bye</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>inheritance pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>Inheritance</title>
    <url>/2021/01/23/inheritance/</url>
    <content><![CDATA[<p>자바스크립트에서 상속을 구현하는 방법들</p>
<a id="more"></a>


<p>상속방법이 생각보다 너무 간단해서 놀랐다.. 자바스크립트는 별거 아니지만 대단한 놈이다 역시</p>
<h2 id="상속-방법-세가지"><a href="#상속-방법-세가지" class="headerlink" title="상속 방법 세가지"></a>상속 방법 세가지</h2><ol>
<li>functional</li>
<li>pseudo classical</li>
<li>class</li>
</ol>
<p>여기서는 functional 한 방법은 빼고 pseudo classical 과 class 를 이용한 방법을 구현하겠다.</p>
<h2 id="pseudo-classical"><a href="#pseudo-classical" class="headerlink" title="pseudo classical"></a>pseudo classical</h2><p>부모객체 생성자와 상속받을 자식객체의 <strong>생성자</strong>를 준비한다.<br>클래스 역할로 사용한다는 의미에서 <code>Pascal Case</code>로 작성한다. 여기서는 동물과 사람을 사용하겠다.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 부모객체 생성자</span></span><br><span class="line"><span class="keyword">const</span> Animal = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 속성</span></span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&quot;동물&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 기능추가</span></span><br><span class="line">Animal.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params">hi</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> hi;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 자식객체의 생성자</span></span><br><span class="line"><span class="keyword">const</span> Human = <span class="function"><span class="keyword">function</span> (<span class="params">age, height</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 부모의 this가 자식의 this와 연결되게 바인딩</span></span><br><span class="line">  Animal.call(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&quot;사람&quot;</span>;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.height = height;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>아직 상속이 끝나지 않았다.<br><strong>기능을 상속</strong>받아야 하고<br>기능을 상속받으면 부모의 생성자가 자식에게 상속되었기 때문에<br>자식의 생성자로 새로운 객체의 <strong>constructor</strong>를 변경해주어야한다.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 부모의 기능은 이것으로 연결한다. 부모의 prototype을 복사해서 자식에 할당한다.</span></span><br><span class="line">Human.prototype = <span class="built_in">Object</span>.create(Animal.prototype);</span><br><span class="line"><span class="comment">// 부모의 생성자 대신 자식의 생성자로 변경 -- 이걸 안하면 constructor 가 부모인 상태가 된다.</span></span><br><span class="line">Human.prototype.constructor = Human;</span><br><span class="line"><span class="comment">// 자식에게 기능추가</span></span><br><span class="line">Human.prototype.bye = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;bye bye&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 물려받은 부모기능 변경</span></span><br><span class="line">Human.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>상속이 잘 구현됐는지 확인해보자</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ani = <span class="keyword">new</span> Animal();</span><br><span class="line">ani.say(<span class="string">&quot;어흥&quot;</span>);</span><br><span class="line"><span class="comment">// 어흥</span></span><br><span class="line"><span class="keyword">const</span> afashs = <span class="keyword">new</span> Human(<span class="number">18</span>, <span class="number">173</span>);</span><br><span class="line">afashs.age;</span><br><span class="line"><span class="comment">// 18</span></span><br><span class="line">afashs.bye();</span><br><span class="line"><span class="comment">// bye bye</span></span><br><span class="line">afashs.say();</span><br><span class="line"><span class="comment">// hello</span></span><br></pre></td></tr></table></figure>
<h2 id="ES6-syntax-class-super"><a href="#ES6-syntax-class-super" class="headerlink" title="ES6 syntax (class/ super)"></a>ES6 syntax (class/ super)</h2><p>절차는 같다. 부모와 자식인데 클래스문법을 사용한다. 자바가 매우 생각나게 하는 문법이다.<br>진짜 이거 보니까 자바….스크립트 같다.<br>원래 자바랑 1 도 관련 없던 언어인데 말이지</p>
<p><strong>super()</strong> 도 원래 자바에 있던건데 이것도 추가됐나보다.<br>부모클래스의 속성,기능등을 super()라는 메소드를 통해 접근 가능함.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 부모클래스</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 속성</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;동물&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//기능</span></span><br><span class="line">  <span class="function"><span class="title">say</span>(<span class="params">hi</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> hi;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 자식클래스 (상속은 extends로)</span></span><br><span class="line"><span class="comment">// 주의! 다중상속 지원안됨 자바에서도 원래 안되지만 implement 라는 기능이 있는데 여기는 없음)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">age, height</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 속성 상속</span></span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;사람&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.height = height;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 기능추가</span></span><br><span class="line">  <span class="function"><span class="title">bye</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;byebye&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 기능변경</span></span><br><span class="line">  <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 기능도 super로 상속받을 수 있음</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.say(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>자 확인해보자</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ani = <span class="keyword">new</span> Animal();</span><br><span class="line">ani.say(<span class="string">&quot;어흥&quot;</span>);</span><br><span class="line"><span class="comment">// 어흥</span></span><br><span class="line"><span class="keyword">const</span> afashs = <span class="keyword">new</span> Human(<span class="number">18</span>, <span class="number">173</span>);</span><br><span class="line">afashs.age;</span><br><span class="line"><span class="comment">// 18</span></span><br><span class="line">afashs.bye();</span><br><span class="line"><span class="comment">// byebye</span></span><br><span class="line">afashs.say();</span><br><span class="line"><span class="comment">// hello</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>inheritance pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>queue, stack</title>
    <url>/2021/01/23/queue/</url>
    <content><![CDATA[<p>스택으로 큐를 구현해보고, 큐로 스택을 구현해보면서 분석해보자.<br>Implement Queue using Stack, Implement Stack using Queue</p>
<a id="more"></a>

<h2 id="역사"><a href="#역사" class="headerlink" title="역사"></a>역사</h2><p>스택은 누가 만든걸까?<br>기록으로만 보면 아이디어는 1946년 우리 튜링 아저씨가 냈고 특허를 낸건 독일사람임.<br>튜링은 아시다시피 2차 세계대전, 전쟁때 컴퓨터의 발전속도를 굉장히 끌어올린 사람이다.<br>이 사람이 전쟁중에 암호해독기 만들었거든 튜링기계인가 먼가<br>폰 노이만(주기억장치, 보조기억장치 etc… 이 컴퓨터 구조 만든사람) 제자임<br>결론적으로 이 글은 영국에서 시작되었으며… 하아… 심지어 스택이란게 만들어진지 50년도 안되었음.<br>그럼 큐는? 그 이전 1900년대 초반부터 있었던 큐잉이론이란게 있다고 한다.<br>뭐 암튼 막상 컴퓨터에서 활발하게 쓰여진 것은 전쟁과 함께 컴퓨터가 발전된 시기.<br>알고리즘이 컴퓨터과학에서 유용하게 작용하기 시작하고, 많은사람들이 컴퓨터를 알게 된 시기가 아닐까 싶다.<br>2차세계대전부터 그냥 다같이 썼다고 생각하자. 전쟁은 이겨야지.</p>
<h3 id="왜-구현함"><a href="#왜-구현함" class="headerlink" title="왜 구현함?"></a>왜 구현함?</h3><p>기본적인 스택과 큐는 일단 굉장히 유사하다.</p>
<ol>
<li>둘다 1차원적으로 입력과 출력이 나열된다.</li>
<li>입/출력 1번 -&gt; 1개 값이 입/출력 된다.</li>
<li>복잡도가 똑같다 (추가, 삭제에 효율적인 모습을 보인다 근데 중간에 넣는 기능이 없다… ㅋㅋㅋㅋㅋ)</li>
<li>다른점은 스택은 LIFO , 큐는 FIFO</li>
</ol>
<p><img src="http://drive.google.com/uc?export=view&id=1VyjwsZSYCuw8cs4o5AAkr5-NW40Hes03" alt="스택 큐 시간복잡도"></p>
<p>Last In First Out / First In First Out 이다.<br>스택은 벽돌쌓으면 허(리)아(포) , 큐는 줄서세요 폴리스라인 (삐)(뽀)(삐)(뽀)… ㅈㅅ</p>
<h2 id="스택을-이용해서-큐를-구현해보자"><a href="#스택을-이용해서-큐를-구현해보자" class="headerlink" title="스택을 이용해서 큐를 구현해보자"></a>스택을 이용해서 큐를 구현해보자</h2><p>사실 자바스크립트에는 Array객체가 있어서 내장메소드로 엄청쉽게 구현이 된다. 하지만 이건 공부용.</p>
<p>이거는 pop이 중요하다.<br>스택 두개를 쓴다. 스택과 유사하게 push와 pop 만 사용<br>1번 스택이 비어버릴 때까지 2번 스택에 붓는다고 생각하면 메인<code>1,2,3,4,5</code> &gt;&gt; 서브<code>5,4,3,2,1</code> 이런식으로 뒤집혀지게 된다.<br>여기서 뒤집힌 스택을 pop 하나만 해주면 큐처럼 선입 선출 <code>First In First Out</code> 의 효과가 된다.<br>다시 원래대로 돌려놔주면 pop기능 완ㅅ넝<br>나머지 메소드는 간단하게 내장기능을 사용하겠다. (추후에 구현해봐야지)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MyQueue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.inStack = [];</span><br><span class="line">  <span class="built_in">this</span>.outStack = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Push element x to the back of queue. </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">x</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MyQueue.prototype.push = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.inStack.push(x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the element from in front of queue and returns that element.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MyQueue.prototype.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res; </span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">this</span>.inStack.length !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.outStack.push(<span class="built_in">this</span>.inStack.pop());</span><br><span class="line">  &#125;</span><br><span class="line">  res = <span class="built_in">this</span>.outStack.pop();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">this</span>.outStack.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.inStack.push(<span class="built_in">this</span>.outStack.pop());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.outStack = [];</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the front element.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MyQueue.prototype.peek = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.inStack[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns whether the queue is empty.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MyQueue.prototype.empty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.inStack.length === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="큐를-이용해서-스택을-구현해보자"><a href="#큐를-이용해서-스택을-구현해보자" class="headerlink" title="큐를 이용해서 스택을 구현해보자"></a>큐를 이용해서 스택을 구현해보자</h2><p>큐 두개를 쓴다. (unshift 와 pop만 사용 해서 큐와 유사하게 사용)<br>이거는 푸시가 중요하다.<br>큐에 넣긴 넣을건데 한번 다른 큐에 다 넣고! 메인큐에 먼저 넣고 서브큐를 넣어준다.<br>이것도 큐가 뒤집힌 형태가 되는것이다. <code>1,2,3,4,5</code>메인큐 &gt;&gt; <code>5,4,3,2,1</code>서브큐 &gt;&gt; <code>1,2,3,4,5</code>,6 하고 나갈땐 6 부터<br>여기서 메인큐를 pop 하나만 해주면 스택처럼 후입선출 <code>Last In First Out</code> 의 효과가 된다.<br>나머지 메소드는 간단하게 내장기능을 사용하겠다. (추후에 구현해봐야지)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize your data structure here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> MyStack = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.inQ = [];</span><br><span class="line">  <span class="built_in">this</span>.subQ = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Push element x onto stack. </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">x</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MyStack.prototype.push = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">this</span>.inQ.length !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.subQ.unshift(<span class="built_in">this</span>.inQ.pop());</span><br><span class="line">  &#125;</span><br><span class="line">  res = <span class="built_in">this</span>.inQ.unshift(x);</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">this</span>.subQ.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.inQ.unshift(<span class="built_in">this</span>.subQ.pop());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the element on top of the stack and returns that element.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MyStack.prototype.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.inQ.pop();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the top element.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MyStack.prototype.top = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.inQ[<span class="built_in">this</span>.inQ.length - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns whether the stack is empty.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MyStack.prototype.empty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.inQ.length === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>data structure</tag>
      </tags>
  </entry>
</search>
