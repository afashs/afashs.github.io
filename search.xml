<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Object Oriented Programming</title>
    <url>/2021/01/23/oop/</url>
    <content><![CDATA[<p>미리 말하지만 나는 객체지향을 싫어한다. 왜냐면 공부하면 할수록 더 좋은 패러다임이 많고 이에 동의하는 사람들이 존재하기 때문이다.</p>
<a id="more"></a>

<blockquote>
<p>객체 지향 프로그래밍은 캘리포니아에서만 나올 수 있는 것 중 이례적으로 나쁜 아이디어입니다.<br>(Object-oriented programming is an exceptionally bad idea which could only have originated in California.)<br>— Edsger W. Dijkstra</p>
</blockquote>
<p>그럼에도 불구하고 객체지향을 모르는 것은 허용하고 싶지 않다.</p>
<p>어떠한 언어는 객체지향을 기본 패러다임으로 만들어진 언어도 있고 (자바나.. C#같은…)<br>의도하지 않더라도 현실과 많이 닮은 점들이 있기 때문에 코드를 짜다보면 자연스럽게 객체를 짜고있기 때문이다.</p>
<p>자바스크립트 세계관에서는 객체지향이 어떻게 사용되는지 알아보자</p>
<h2 id="객체-Object"><a href="#객체-Object" class="headerlink" title="객체 (Object)"></a>객체 (Object)</h2><p>객체는 무엇인가. 현실의 어떠한 물체를 생각해보자<br>현실의 어떠한 물체는 속성이 있고. 기능이 있다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">무게는 100g 정도 됩니다.<br>색상은 은색입니다.<br>소재는 철과 나무입니다.<br>모양은 대체로 길고 뾰족한 모양입니다.<br>손잡이를 가지고 있습니다.<br>이름은 식칼이라고 부릅니다.<br></code></pre></td></tr></table></figure>
<p>이것은 속성이다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">벨 수 있습니다.<br>찌를 수 있습니다.<br>자를 수 있습니다.<br>손잡이를 이용하여 누를 수 있습니다.<br></code></pre></td></tr></table></figure>
<p>이것은 기능이다.<br>말 그대로 객체는 속성과 기능을 가진 현실의 어떠한 물체를 본따서 컴퓨터에서 사용하려는 것이고, 이렇게 만들어진 것이 Object 인 것이다.</p>
<h2 id="객체지향"><a href="#객체지향" class="headerlink" title="객체지향"></a>객체지향</h2><p>앞서 설명한 Object를 만들었다면 이러한 Object를 적극 활용하여 프로그래밍을 하자는 패러다임..<br>객체지향에서는 이 객체를 적극적으로 활용하기 위하여 몇가지 객체의 특징들을 약속해놓았다.</p>
<h3 id="객체지향의-특징"><a href="#객체지향의-특징" class="headerlink" title="객체지향의 특징"></a>객체지향의 특징</h3><p>캡슐화 (Encapsulation)<br>추상화 (Abstraction)<br>상속 (Inheritance)<br>다형성 (Polymorphism)</p>
<h4 id="캡슐화-Encapsulation"><a href="#캡슐화-Encapsulation" class="headerlink" title="캡슐화 (Encapsulation)"></a>캡슐화 (Encapsulation)</h4><p>캡슐화하는 이유는 두가지다.</p>
<p>편의적인 면<br>보안적인 면<br>자 아무것도 없는 도마위에 원산지 라고만 쓰여있다.<br>이러면 당연히 무엇의 원산지인지 모르지 않을까?<br>그런데 식칼에 “원산지” 라고 쓰여있다.<br>식칼의 원산지일 것이라고 사람들은 연상하게 된다.<br>그래서 우리는 프로그래밍에서도 도마위에 식칼의원산지, 생선의원산지, 이런식으로 일일히 나열하는 것이 아닌.<br>생선을 만들고 그 안에 속성으로 원산지를 넣어주고,<br>식칼을 만들고 그 안에 속성으로 원산지를 넣어주어 캡슐화시킨다.<br>편리하지 않은가</p>
<p>그렇다면 보안적인 면은 어떨까?<br>이것이 정확히 몇%의 합금인지 남들에게 알리고 싶지 않다면, 사실 이것을 남들에게 상해를 입힐 수 있는 기능도 있다는 것을 알리고 싶지 않다면?<br>이것을 숨기고 그냥 난 식칼이야 요리할때 써. 라고 건네주는 것만으로도 충분히 이 Object의 역할은 달성하지 않았을까<br>Object 의 숨기고 싶은 면, 혹은 굳이 안보여 줘도 되는 면들을 캡슐화를 통해 숨길 수 있다</p>
<h4 id="추상화-abstraction"><a href="#추상화-abstraction" class="headerlink" title="추상화 (abstraction)"></a>추상화 (abstraction)</h4><p>객체에게 부탁한다. 이것좀 건네줘.<br>그런데 사실 이 건네준다는 게 엄청나게 복잡하다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">이두근을 이완시켜 펼치고.<br>다섯손가락 두번째마디들을 굽혀서 0.7J의 힘으로 누른 뒤<br>다시 이두근을 45 수축 시킨뒤 상체를 돌려 나를 바라봐.<br>그 이후 손을 펴서 나에게 건내줘.<br>더 쪼갤 수 있는데 그만 쪼개겠다.<br>하고싶은 말은 이것이다. 여기서 중요한 부분만을 추려낸다.<br>물건을 들고, 나를보고, 건내줘.<br></code></pre></td></tr></table></figure>
<p>물건또한 마찬가지겠지.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">사과가 대체로 빨갛지만. 사실은 상단부분은 체리애플블라썸 색이고, 중단부분은 베리베리스트로베리 색이고 하단부분은 로열레드 색이다.<br>근데 그냥 빨갛다고 부르겠다.<br></code></pre></td></tr></table></figure>
<p>자 이게 추상화다. 일련의 복잡한 과정, 속성들을 축약하고, 간소화시키는 것.<br>이러한 추상화가 깊어질수록 우리는 이 복잡한 것을 간단하게 볼 수 있게 된다.</p>
<h4 id="상속-Inheritance"><a href="#상속-Inheritance" class="headerlink" title="상속 (Inheritance)"></a>상속 (Inheritance)</h4><p>상속은 생각보다 간단하다. 상속은 특히 웃긴게 무수히 많은 상속이 가능하다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">동물이 있다. 동물은 보통 이름이 있고, 생명활동을 한다.<br>해양동물이 있다. 해양동물은 동물의 속성과 기능을 모두 갖고 있으며, 서식지가 바다이다<br>갑각류가 있다. 갑각류는 해양동물의 속성과 기능을 모두 갖고 있으며, 피부가 단단하다.<br>어류가 있다. 어류는 해양동물의 속성과 기능을 모두 갖고 있으며, 아가미로 호흡한다.<br>참치가 있다. 참치는 어류의 속성과 기능을 모두 갖고 있으며, 지방질이 풍부하고 깊은곳에 서식한다.<br></code></pre></td></tr></table></figure>
<p>정리해보자. 동물 &gt; 해양동물 &gt; 어류 &gt; 참치<br>여기서 화살표가 상속 이다.<br>부모의 속성과 기능이 자식에도 존재한다.<br>주의해야 할점은. 부모가 자식때문에 필요없는 속성을 갖고 있지 않게 표현해야 하고.<br>상속하지 않고 같은 부모를 사용해야 할 때를 구분하는 것이다.<br>여기서는 갑각류와 어류같이 해양생물 정도만 공통적이고 나머지는 차이가 존재하기 때문에 추가 상속하지 않았다.</p>
<h4 id="다형성-Polymophism"><a href="#다형성-Polymophism" class="headerlink" title="다형성 (Polymophism)"></a>다형성 (Polymophism)</h4><p>사람이라는 Object가 있다. 이 사람은 동물을 상속받았다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">사람.인사해()<br>헬로<br></code></pre></td></tr></table></figure>
<p>예측된 결과다. 그럼 이번엔 개에게 시키겠다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">개.인사해()<br>헬로<br></code></pre></td></tr></table></figure>
<p>응? 이러한 일이 발생하지 않게 같은 이름의 기능이라도 다르게 작동시킬 수 있게 해주는 특징이 다형성이다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">개.인사해()<br>멍<br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">고양이.인사해()<br>야옹<br></code></pre></td></tr></table></figure>
<p>다형성이 있어야 이러한 편리한 기능이 구현된다. 자바에서는 이를 구현하는 오버로딩과 오버라이딩이라는 방법이 있는데<br>여기서는 언급하지 않겠다.</p>
<h2 id="인스턴스"><a href="#인스턴스" class="headerlink" title="인스턴스"></a>인스턴스</h2><p>자바에서는 클래스라는게 있다.</p>
<p>클래스는 공장에서 물건을 찍어내는 틀, 사진을 찍어내는 청사진과 같다.<br>우리가 식칼을 만들려고 한다. 그때마다 위에서 설명 한 속성과 기능들을 나열해야 한다면?</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">무게는 100g 정도 됩니다.<br>색상은 은색입니다.<br>소재는 철과 나무입니다.<br>모양은 대체로 길고 뾰족한 모양입니다.<br>손잡이를 가지고 있습니다.<br>이름은 식칼이라고 부릅니다.<br>벨 수 있습니다.<br>찌를 수 있습니다.<br>자를 수 있습니다.<br>손잡이를 이용하여 누를 수 있습니다.<br></code></pre></td></tr></table></figure>
<p>이런 물체를 만들어줘. 매번 이렇게 부탁할것인가?<br>자 이렇게 해보자<br>앞으로 내가 식칼클래스를 쓰면 항상 위에 나열한 속성과 기능이 담겨있어야 해.</p>
<p>자 그럼 사용해보자</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">식칼클래스로 식칼을 만들어줘.<br></code></pre></td></tr></table></figure>
<p>여기서 만들어진 식칼이 인스턴스 라는거다.<br>즉 한개의 클래스로 많은 인스턴스를 만들수 있다.</p>
<p>그러면 자바스크립트에서는??</p>
<p>자바스크립트에서는 클래스가 아니라 함수로 인스턴스를 만든다</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br></code></pre></td></tr></table></figure>
<p>함수를 실행했는데 인스턴스가 만들어졌다. 어떻게?<br>여기서 사용되는 게 prototype 이다 알아보자.</p>
<h2 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h2><p>자바스크립트 객체는 Prototype이라는 내부 프로퍼티가 존재한다.<br>prototype은 본인이 원래 가져야할 속성과 기능의 명세. 즉 클래스와 같은 역할을 하고 있다.</p>
<p>객체를 생성하면 자신이 상속받은 부모의 prototype은 <code>__proto__</code> 속성에 연결한다.<br>이를 통해 자바스크립트의 모든 객체는 자신의 부모 역할을 담당하는 객체와 연결되어 있다.<br>이것은 <strong>프로토타입</strong> 링크 라고 하겠다.<br>특정 객체의 프로퍼티나 메소드에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티 또는 메소드가 없다면<br><code>__proto__</code>이 가리키는 링크를 따라 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티나 메소드를 차례대로 검색한다.<br>이것을 <strong>프로토타입 체인</strong>이라 한다.</p>
<p>자 이건 알겠고 그렇다면 함수는?</p>
<p>함수를 정의하면 함수만 생성되는 것이 아니라 Prototype Object도 같이 생성이 된다.<br>Prototype Object는 <code>constructor</code>와 <code>__proto__</code>를 가지고 있다.<br>constructor는 함수인데. 이 함수는 만들어질 객체가 가져야할 property들이 정의되어 있다.<br>new 키워드와 함께 함수를 호출할 경우 constructor함수를 실행하고 <code>__proto__</code> 를 부모의prototype과 연결한다.<br>new로써 만들어진 모든 객체는 결국 부모.prototype 과 <code>__proto__</code> 링크로 연결된다는 것이다.</p>
<p>결과적으로 이렇게 된다.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">instance.__proto__ === <span class="hljs-built_in">Object</span>.prototype<br><span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
<h3 id="인스턴스를-만드는-방법-실습"><a href="#인스턴스를-만드는-방법-실습" class="headerlink" title="인스턴스를 만드는 방법 실습"></a>인스턴스를 만드는 방법 실습</h3><h4 id="functional"><a href="#functional" class="headerlink" title="functional"></a>functional</h4><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> Human = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> instance = &#123;&#125;;<br><br>  instance.name = <span class="hljs-string">&#x27;functional instantiation&#x27;</span>;<br>  instance.func = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;기능입니다.&quot;</span>)<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> instance;<br>&#125;<br><br><span class="hljs-keyword">let</span> instance = Human();<br><br>instance.name;<br><span class="hljs-comment">// functional instantiation</span><br><br>instance.func();<br><span class="hljs-comment">// 기능입니다.</span><br>functional shared<br><span class="hljs-keyword">const</span> extend = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> <span class="hljs-keyword">from</span>) &#123;<br>    to[key] = <span class="hljs-keyword">from</span>[key];<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> sharedFunc = &#123;&#125;;<br>sharedFunc.say = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">hi</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.say = hi;<br>&#125;<br><br><span class="hljs-keyword">const</span> Human = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> instance = &#123;&#125;;<br><br>  instance.name = <span class="hljs-string">&#x27;functional shared instantiation&#x27;</span>;<br>  instance.func = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;기능입니다.&quot;</span>)<br>  &#125;;<br>  extend(instance, sharedFunc);<br><br>  <span class="hljs-keyword">return</span> instance;<br>&#125;<br><span class="hljs-keyword">let</span> instance = Human();<br><br>instance.name;<br><span class="hljs-comment">// functional shared instantiation</span><br><br>instance.func();<br><span class="hljs-comment">// 기능입니다.</span><br><br>instance.say(<span class="hljs-string">&quot;hello&quot;</span>);<br>instance.say;<br><span class="hljs-comment">// hello</span><br></code></pre></td></tr></table></figure>
<h4 id="prototypal"><a href="#prototypal" class="headerlink" title="prototypal"></a>prototypal</h4><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> method = &#123;&#125;;<br> method.say = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">hi</span>) </span>&#123;<br>   <span class="hljs-built_in">this</span>.say = hi<br>&#125;<br><br><span class="hljs-keyword">const</span> Human = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> instance = <span class="hljs-built_in">Object</span>.create(method);<br><br>  instance.name = <span class="hljs-string">&#x27;prototypal instantiation&#x27;</span>;<br>  instance.func = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;기능입니다.&quot;</span>)<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> instance;<br>&#125;<br><br><span class="hljs-keyword">const</span> instance = Human();<br><br>instance.name;<br><span class="hljs-comment">// prototypal instantiation</span><br></code></pre></td></tr></table></figure>
<h4 id="PseudoClassical"><a href="#PseudoClassical" class="headerlink" title="PseudoClassical"></a>PseudoClassical</h4><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> Human = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">hi</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.say = hi;<br>&#125;<br><br>Human.prototype.bye = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;bye bye&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> Human(<span class="hljs-string">&quot;hello&quot;</span>);<br><br>instance.say;<br><span class="hljs-comment">// hello</span><br><br>instance.bye();<br><span class="hljs-comment">// bye bye</span><br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>inheritance pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>queue, stack</title>
    <url>/2021/01/23/queuestack/</url>
    <content><![CDATA[<p>스택으로 큐를 구현해보고, 큐로 스택을 구현해보면서 분석해보자.<br>Implement Queue using Stack, Implement Stack using Queue</p>
<a id="more"></a>

<h2 id="역사"><a href="#역사" class="headerlink" title="역사"></a>역사</h2><p>스택은 누가 만든걸까?<br>기록으로만 보면 아이디어는 1946년 우리 튜링 아저씨가 냈고 특허를 낸건 독일사람임.<br>튜링은 아시다시피 2차 세계대전, 전쟁때 컴퓨터의 발전속도를 굉장히 끌어올린 사람이다.<br>이 사람이 전쟁중에 암호해독기 만들었거든 튜링기계인가 먼가<br>폰 노이만(주기억장치, 보조기억장치 etc… 이 컴퓨터 구조 만든사람) 제자임<br>결론적으로 이 글은 영국에서 시작되었으며… 하아… 심지어 스택이란게 만들어진지 50년도 안되었음.<br>그럼 큐는? 그 이전 1900년대 초반부터 있었던 큐잉이론이란게 있다고 한다.<br>뭐 암튼 막상 컴퓨터에서 활발하게 쓰여진 것은 전쟁과 함께 컴퓨터가 발전된 시기.<br>알고리즘이 컴퓨터과학에서 유용하게 작용하기 시작하고, 많은사람들이 컴퓨터를 알게 된 시기가 아닐까 싶다.<br>2차세계대전부터 그냥 다같이 썼다고 생각하자. 전쟁은 이겨야지.</p>
<h3 id="왜-구현함"><a href="#왜-구현함" class="headerlink" title="왜 구현함?"></a>왜 구현함?</h3><p>기본적인 스택과 큐는 일단 굉장히 유사하다.</p>
<ol>
<li>둘다 1차원적으로 입력과 출력이 나열된다.</li>
<li>입/출력 1번 -&gt; 1개 값이 입/출력 된다.</li>
<li>복잡도가 똑같다 (추가, 삭제에 효율적인 모습을 보인다 근데 중간에 넣는 기능이 없다… ㅋㅋㅋㅋㅋ)</li>
<li>다른점은 스택은 LIFO , 큐는 FIFO</li>
</ol>
<p><img src="http://drive.google.com/uc?export=view&id=1VyjwsZSYCuw8cs4o5AAkr5-NW40Hes03" alt="스택 큐 시간복잡도"></p>
<p>Last In First Out / First In First Out 이다.<br>스택은 벽돌쌓으면 허(리)아(포) , 큐는 줄서세요 폴리스라인 (삐)(뽀)(삐)(뽀)… ㅈㅅ</p>
<h2 id="스택을-이용해서-큐를-구현해보자"><a href="#스택을-이용해서-큐를-구현해보자" class="headerlink" title="스택을 이용해서 큐를 구현해보자"></a>스택을 이용해서 큐를 구현해보자</h2><p>사실 자바스크립트에는 Array객체가 있어서 내장메소드로 엄청쉽게 구현이 된다. 하지만 이건 공부용.</p>
<p>이거는 pop이 중요하다.<br>스택 두개를 쓴다. 스택과 유사하게 push와 pop 만 사용<br>1번 스택이 비어버릴 때까지 2번 스택에 붓는다고 생각하면 메인<code>1,2,3,4,5</code> &gt;&gt; 서브<code>5,4,3,2,1</code> 이런식으로 뒤집혀지게 된다.<br>여기서 뒤집힌 스택을 pop 하나만 해주면 큐처럼 선입 선출 <code>First In First Out</code> 의 효과가 된다.<br>다시 원래대로 돌려놔주면 pop기능 완성<br>나머지 메소드는 간단하게 내장기능을 사용하겠다. (추후에 구현해봐야지)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MyQueue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.inStack = [];</span><br><span class="line">  <span class="built_in">this</span>.outStack = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Push element x to the back of queue. </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">x</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MyQueue.prototype.push = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.inStack.push(x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the element from in front of queue and returns that element.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MyQueue.prototype.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res; </span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">this</span>.inStack.length !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.outStack.push(<span class="built_in">this</span>.inStack.pop());</span><br><span class="line">  &#125;</span><br><span class="line">  res = <span class="built_in">this</span>.outStack.pop();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">this</span>.outStack.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.inStack.push(<span class="built_in">this</span>.outStack.pop());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.outStack = [];</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the front element.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MyQueue.prototype.peek = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.inStack[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns whether the queue is empty.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MyQueue.prototype.empty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.inStack.length === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="큐를-이용해서-스택을-구현해보자"><a href="#큐를-이용해서-스택을-구현해보자" class="headerlink" title="큐를 이용해서 스택을 구현해보자"></a>큐를 이용해서 스택을 구현해보자</h2><p>큐 두개를 쓴다. (unshift 와 pop만 사용 해서 큐와 유사하게 사용)<br>이거는 푸시가 중요하다.<br>큐에 넣긴 넣을건데 한번 다른 큐에 다 넣고! 메인큐에 먼저 넣고 서브큐를 넣어준다.<br>이것도 큐가 뒤집힌 형태가 되는것이다. <code>1,2,3,4,5</code>메인큐 &gt;&gt; <code>5,4,3,2,1</code>서브큐 &gt;&gt; <code>1,2,3,4,5</code>,6 하고 나갈땐 6 부터<br>여기서 메인큐를 pop 하나만 해주면 스택처럼 후입선출 <code>Last In First Out</code> 의 효과가 된다.<br>나머지 메소드는 간단하게 내장기능을 사용하겠다. (추후에 구현해봐야지)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize your data structure here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> MyStack = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.inQ = [];</span><br><span class="line">  <span class="built_in">this</span>.subQ = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Push element x onto stack. </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">x</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MyStack.prototype.push = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">this</span>.inQ.length !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.subQ.unshift(<span class="built_in">this</span>.inQ.pop());</span><br><span class="line">  &#125;</span><br><span class="line">  res = <span class="built_in">this</span>.inQ.unshift(x);</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">this</span>.subQ.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.inQ.unshift(<span class="built_in">this</span>.subQ.pop());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the element on top of the stack and returns that element.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MyStack.prototype.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.inQ.pop();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the top element.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MyStack.prototype.top = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.inQ[<span class="built_in">this</span>.inQ.length - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns whether the stack is empty.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MyStack.prototype.empty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.inQ.length === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>Inheritance</title>
    <url>/2021/01/23/inheritance/</url>
    <content><![CDATA[<p>자바스크립트에서 상속을 구현하는 방법들</p>
<a id="more"></a>


<p>상속방법이 생각보다 너무 간단해서 놀랐다.. 자바스크립트는 별거 아니지만 대단한 놈이다 역시</p>
<h2 id="상속-방법-세가지"><a href="#상속-방법-세가지" class="headerlink" title="상속 방법 세가지"></a>상속 방법 세가지</h2><ol>
<li>functional</li>
<li>pseudo classical</li>
<li>class</li>
</ol>
<p>여기서는 functional 한 방법은 빼고 pseudo classical 과 class 를 이용한 방법을 구현하겠다.</p>
<h2 id="pseudo-classical"><a href="#pseudo-classical" class="headerlink" title="pseudo classical"></a>pseudo classical</h2><p>부모객체 생성자와 상속받을 자식객체의 <strong>생성자</strong>를 준비한다.<br>클래스 역할로 사용한다는 의미에서 <code>Pascal Case</code>로 작성한다. 여기서는 동물과 사람을 사용하겠다.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 부모객체 생성자</span><br><span class="hljs-keyword">const</span> Animal = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 속성</span><br>  <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&quot;동물&quot;</span>;<br>&#125;;<br><span class="hljs-comment">// 기능추가</span><br>Animal.prototype.say = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">hi</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> hi;<br>&#125;;<br><br><span class="hljs-comment">// 자식객체의 생성자</span><br><span class="hljs-keyword">const</span> Human = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">age, height</span>) </span>&#123;<br>  <span class="hljs-comment">// 부모의 this가 자식의 this와 연결되게 바인딩</span><br>  Animal.call(<span class="hljs-built_in">this</span>);<br>  <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&quot;사람&quot;</span>;<br>  <span class="hljs-built_in">this</span>.age = age;<br>  <span class="hljs-built_in">this</span>.height = height;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>아직 상속이 끝나지 않았다.<br><strong>기능을 상속</strong>받아야 하고<br>기능을 상속받으면 부모의 생성자가 자식에게 상속되었기 때문에<br>자식의 생성자로 새로운 객체의 <strong>constructor</strong>를 변경해주어야한다.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 부모의 기능은 이것으로 연결한다. 부모의 prototype을 복사해서 자식에 할당한다.</span><br>Human.prototype = <span class="hljs-built_in">Object</span>.create(Animal.prototype);<br><span class="hljs-comment">// 부모의 생성자 대신 자식의 생성자로 변경 -- 이걸 안하면 constructor 가 부모인 상태가 된다.</span><br>Human.prototype.constructor = Human;<br><span class="hljs-comment">// 자식에게 기능추가</span><br>Human.prototype.bye = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;bye bye&quot;</span>;<br>&#125;;<br><span class="hljs-comment">// 물려받은 부모기능 변경</span><br>Human.prototype.say = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>상속이 잘 구현됐는지 확인해보자</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> ani = <span class="hljs-keyword">new</span> Animal();<br>ani.say(<span class="hljs-string">&quot;어흥&quot;</span>);<br><span class="hljs-comment">// 어흥</span><br><span class="hljs-keyword">const</span> afashs = <span class="hljs-keyword">new</span> Human(<span class="hljs-number">18</span>, <span class="hljs-number">173</span>);<br>afashs.age;<br><span class="hljs-comment">// 18</span><br>afashs.bye();<br><span class="hljs-comment">// bye bye</span><br>afashs.say();<br><span class="hljs-comment">// hello</span><br></code></pre></td></tr></table></figure>
<h2 id="ES6-syntax-class-super"><a href="#ES6-syntax-class-super" class="headerlink" title="ES6 syntax (class/ super)"></a>ES6 syntax (class/ super)</h2><p>절차는 같다. 부모와 자식인데 클래스문법을 사용한다. 자바가 매우 생각나게 하는 문법이다.<br>진짜 이거 보니까 자바….스크립트 같다.<br>원래 자바랑 1 도 관련 없던 언어인데 말이지</p>
<p><strong>super()</strong> 도 원래 자바에 있던건데 이것도 추가됐나보다.<br>부모클래스의 속성,기능등을 super()라는 메소드를 통해 접근 가능함.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 부모클래스</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-comment">// 속성</span><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;동물&#x27;</span>;<br>  &#125;<br>  <span class="hljs-comment">//기능</span><br>  <span class="hljs-function"><span class="hljs-title">say</span>(<span class="hljs-params">hi</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> hi;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 자식클래스 (상속은 extends로)</span><br><span class="hljs-comment">// 주의! 다중상속 지원안됨 자바에서도 원래 안되지만 implement 라는 기능이 있는데 여기는 없음)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">age, height</span>)</span> &#123;<br>    <span class="hljs-comment">// 속성 상속</span><br>    <span class="hljs-built_in">super</span>();<br>    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;사람&#x27;</span>;<br>    <span class="hljs-built_in">this</span>.age = age;<br>    <span class="hljs-built_in">this</span>.height = height;<br>  &#125;<br>  <span class="hljs-comment">// 기능추가</span><br>  <span class="hljs-function"><span class="hljs-title">bye</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;byebye&#x27;</span>;<br>  &#125;<br>  <span class="hljs-comment">// 기능변경</span><br>  <span class="hljs-function"><span class="hljs-title">say</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// 기능도 super로 상속받을 수 있음</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.say(<span class="hljs-string">&quot;hello&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>자 확인해보자</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> ani = <span class="hljs-keyword">new</span> Animal();<br>ani.say(<span class="hljs-string">&quot;어흥&quot;</span>);<br><span class="hljs-comment">// 어흥</span><br><span class="hljs-keyword">const</span> afashs = <span class="hljs-keyword">new</span> Human(<span class="hljs-number">18</span>, <span class="hljs-number">173</span>);<br>afashs.age;<br><span class="hljs-comment">// 18</span><br>afashs.bye();<br><span class="hljs-comment">// byebye</span><br>afashs.say();<br><span class="hljs-comment">// hello</span><br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>inheritance pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>package.json</title>
    <url>/2021/02/05/package-json/</url>
    <content><![CDATA[<p>package.json</p>
<a id="more"></a>

<h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>node package manager<br>노드js 생태계의 특징 중 하나. 각종 오픈소스 라이브러리를 설치, 관리해주는 툴<br>내 node 프로젝트에 쉽게 모듈화 되어있는 라이브러리를 추가하고 관리할 수 있다.</p>
<h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><p>npm 에서 라이브러리들을 관리해 줄 수 있게 나의 node프로젝트의 버전, 이름과 필요한 라이브러리들을 명시해 놓은 명세서와 같다.<br>명세서에 적힌 라이브러리들을 <code>npm install</code> 을 통하여 설치할 수 있으며 <code>save</code>를 통하여 이곳에 필요한 라이브러리들을 추가하여<br>어떤 라이브러리가 이 프로젝트에 포함되어야 하는지 명시해 줄 수 있다.</p>
]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>url</title>
    <url>/2021/02/05/url/</url>
    <content><![CDATA[<p>url 용어정리</p>
<a id="more"></a>

<p>그림 한장으로 깔끔한 설명이 가능하다.</p>
<p><img src="http://drive.google.com/uc?export=view&id=1fhr54MHXS0x3q3uKnD6oOTav-sw0E5ys" alt="url 용어정리"></p>
]]></content>
      <categories>
        <category>network</category>
      </categories>
  </entry>
  <entry>
    <title>구글드라이브 image link converter</title>
    <url>/2021/02/05/converter/</url>
    <content><![CDATA[<p>구글드라이브를 이미지 서버로 사용하고 싶을 때 공유할 수 있는 이미지 링크로 변환해주는 툴</p>
<a id="more"></a>

<p>사용법은 컨버터 하단에 있습니다</p>
<h2 id="컨버터"><a href="#컨버터" class="headerlink" title="컨버터"></a>컨버터</h2>  <style>
    #converter {
      padding: 20px 20px;
      border-radius: 5px;
      background-color: #f8f8f8;
      width: 100%;
      padding: 15px 15px;
    }

    #converter textarea {
      display: block;
      white-space: wrap;
      border: 1px solid #888;
      border-radius: 5px;
      margin-bottom: 10px;
      padding: 5px 5px;
      width: 100%;
      height: 60px;
    }

    #converter label {
      font-weight: bold;
      color: #333;
    }

    #converter button {
      font-weight: bold;
    }

    #btn-convert {
      width: 100%;
    }

    #convert-result {
      margin-top: 20px;
    }
  </style>
  <div id="converter">
    <label>Google Drive path</label>
    <textarea id="gd-url" placeholder="Input Google Drive Url"></textarea>
    <button id="btn-convert" class="btn btn-primary">Make Google Drive Path Linkable</button>
    <div id="convert-result">
      <label for="result">Linkable Image path</label>
      <textarea id="result" name="result" readonly></textarea>
      <button id="btn-save-result-cb" class="btn btn-success pull-right" data-clipboard-target="#result">
        <span class="glyphicon glyphicon-copy" aria-hidden="true"></span>
        Save to Clipboard
      </button>
      <br><br>
      <label for="result-img-tag">Image Tag</label>
      <textarea id="result-img-tag" name="result" readonly></textarea>
      <button id="btn-save-result-img-tag-cb" class="btn btn-success pull-right" data-clipboard-target="#result-img-tag">
        <span class="glyphicon glyphicon-copy" aria-hidden="true"></span>
        Save to Clipboard
      </button>
    </div>
    <br><br><br>
      <p align="center">
      <b>Preview image</b>
      </p>
    <p align="center">
      <img id="preview" alt="image preview" src='https://www.google.com/drive/static/images/drive/logo-drive.png' class="img-thumbnail" style="max-width: 200px"/><br>
    </p>

  </div>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/clipboard.min.js"></script>
  <script>
    var gdUrl = $("#gd-url");
    $("#btn-convert").on("click", function(event) {

      if (!isValidUrl(gdUrl.val())) {
        alert("You have inputted invalid path.");
        gdUrl.val("");
        return;
      }

      var gdId = extractFileId(gdUrl.val());
      var prefix = "http://drive.google.com/uc?export=view&id=";
      $("#result").val(prefix + gdId);
      $("#result-img-tag").val(
        "<img src='" +
        prefix + gdId +
        "' /><br>");
      $("#preview").attr("src", prefix + gdId);
    });

    var clipboard = new Clipboard('.btn');

    clipboard.on('success', function(e) {
      console.info('Action:', e.action);
      console.info('Text:', e.text);
      console.info('Trigger:', e.trigger);

      e.clearSelection();
    });

    clipboard.on('error', function(e) {
      console.error('Action:', e.action);
      console.error('Trigger:', e.trigger);
    });

    // validity check. ref: https://gist.github.com/jlong/2428561
    function isValidUrl(url) {
      // to be impl...
      var parser = document.createElement('a');
      parser.href = url;

      if(url === '' || parser.hostname !== "drive.google.com" || !parser.pathname.includes("/file/d/"))
        return false;

      return true;
    }

    function extractFileId(url) {
      if (!url) 
        url = window.location.href;

      var strip = url.replace(/https:\/\/drive.google.com\/file\/d\//gi, "")
      .replace(/\/view\?[a-zA-Z=\/]+/gi, "");

      return strip;
    }
  </script>


<h2 id="사용법"><a href="#사용법" class="headerlink" title="사용법"></a>사용법</h2><ol>
<li>구글 드라이브에 파일을 올리고 해당 이미지를 우클릭 -&gt; 공유<br><img src="http://drive.google.com/uc?export=view&id=1KqxOiJvc8vEN1du2PkCnnGf6DYt0FPC3" alt="공유"></li>
<li>링크가 있는 모든 사용자로 변경<br><img src="http://drive.google.com/uc?export=view&id=1bgPtFxedp2fxjNoXBttxobxNIcADrQzz" alt="모든사용자로 변경"></li>
<li>생성된 링크 복사<br><img src="http://drive.google.com/uc?export=view&id=1xpt9jc5OM5z312oXtciUvENilRPp2CGD" alt="생성된 링크 복사"></li>
<li>링크를 컨버터 <code>Google Drive path</code> 에 입력</li>
<li>변환된 링크<code>Linkable Image path</code> 이미지태그<code>Image Tag</code>를 붙여넣기 하면 완료!</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>http</title>
    <url>/2021/02/05/http/</url>
    <content><![CDATA[<p>HTTP 헤더에 대한 분석과, 응답 상태 코드 (Status Codes) 그리고 브라우저의 Network 탭 및 브라우저를 통해 일어나는 일들</p>
<a id="more"></a>

<h2 id="url-uri"><a href="#url-uri" class="headerlink" title="url ? uri?"></a>url ? uri?</h2><h3 id="Uniform-Resource-location-말그대로-location"><a href="#Uniform-Resource-location-말그대로-location" class="headerlink" title="Uniform Resource location 말그대로 location!"></a>Uniform Resource location 말그대로 location!</h3><p>문서의 위치를 전해주면 해당 서버의 location에 적혀있는 폴더로 들어가서 파일을 찾아서 준다.<br>과거에는 http 요청에 대해서 서버가 특정 문서를 응답하기만 했다고 한다. 하지만 지금은?</p>
<h3 id="Uniform-Resource-Identifier-말-그대로-식별자"><a href="#Uniform-Resource-Identifier-말-그대로-식별자" class="headerlink" title="Uniform Resource Identifier 말 그대로 식별자"></a>Uniform Resource Identifier 말 그대로 식별자</h3><p>서버에서 파일뿐만 아니라 각종 비즈니스로직을 처리하는 것 또한 가능해졌기 때문에 location이 아닌 좀더 큰 개념으로 식별자 라고 부른다.</p>
<ul>
<li>URL : 파일 응답</li>
<li>URI : 파일 응답 + 비즈니스로직 처리</li>
</ul>
<h2 id="HTTP-헤더에는-무엇이-들어있는가"><a href="#HTTP-헤더에는-무엇이-들어있는가" class="headerlink" title="HTTP 헤더에는 무엇이 들어있는가?"></a>HTTP 헤더에는 무엇이 들어있는가?</h2><p>엄청 많긴 하지만 일단 중요한 몇가지 정도만 알자.</p>
<h3 id="요청-헤더"><a href="#요청-헤더" class="headerlink" title="요청 헤더"></a>요청 헤더</h3><p>요청을 받는 호스트주소<br>http 메소드 (get, post 등등)<br>쿠키 등 인증정보<br>클라이언트의 정보 (브라우저 or OS버전 등)</p>
<h3 id="응답-헤더"><a href="#응답-헤더" class="headerlink" title="응답 헤더"></a>응답 헤더</h3><p>status 코드 (200, 404 등등 많음)<br>응답타입(content type) : 문서인지 json인지… 인코딩은 utf로 되어있는지 등등<br>허용하는 클라이언트 목록 (CORS 정책)</p>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>redux</title>
    <url>/2021/02/22/redux/</url>
    <content><![CDATA[<h2 id="cra리엑트에-리덕스-끼얹기"><a href="#cra리엑트에-리덕스-끼얹기" class="headerlink" title="cra리엑트에 리덕스 끼얹기"></a>cra리엑트에 리덕스 끼얹기</h2><a id="more"></a>

<p>디렉터리 설계방법이 굉장히 다양한데<br>redux 디렉토리를 만들어서 관리하는 방식으로 구현해본다면?</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">  - component</span><br><span class="line">    subscribers.js</span><br><span class="line">    display.js</span><br><span class="line">  - redux</span><br><span class="line">    stors.js</span><br><span class="line">    - subscribers</span><br><span class="line">      types.js</span><br><span class="line">        &#123;ADD_SUBSCRIBER&#125;</span><br><span class="line">        &#123;REMOVE_SUBSCRIBER&#125;</span><br><span class="line">      actions.js</span><br><span class="line">      reducer.js</span><br><span class="line">        &#123;initialState&#125;</span><br><span class="line">        &#123;subscribersReducer(state,action) -&gt; <span class="keyword">switch</span> (ADD... / REMOVE... / <span class="keyword">default</span>)&#125;</span><br></pre></td></tr></table></figure>
<p>app.css 간단하게 바꾸기<br>component만들고 app.js 에 컴포넌트 적용<br>types 먼저 상수로 만들어서 export<br>import 해서 actions 만들기<br>reducer 만들고 actions 분기처리<br>store에 reducer 불러와서 store create 하면 됨</p>
<p>app에서는 {provider} from react-redux 로 감싸주어야 한다.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Provider store=&#123;store&#125;&gt;</span><br></pre></td></tr></table></figure>
<p>component 에서는 connect로 연결해주어야됨 { connect } from react-redux<br>이 커넥트를 이용하면 다른 컴포넌트들에게도 store의 상태를 연결해줄 수 있다.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps)(Subscriber)</span><br></pre></td></tr></table></figure>
<p>redux connect로 검색을 해보면 중간에 들어가는 parameter들을 알 수 있다.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    count: state.count</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>component 에서 { action } from actions<br>함수버전</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    addSubscriber: <span class="function">() =&gt;</span> dispatch(addSubscriber()) <span class="comment">// 받아온 action을 연결해주는 거다.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>객체버전</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = &#123;</span><br><span class="line">  addSubscriber</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>다른 reducer를 만든다면? combine reducer 를 만들어야한다.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">redux/Rootreducer.js</span><br><span class="line"><span class="keyword">import</span> &#123; combineReducer&#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> subReducer <span class="keyword">from</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> viewReducer <span class="keyword">from</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootReducer = combineReducers(&#123;</span><br><span class="line">  views: viewReducer,</span><br><span class="line">  subs: subReducer</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> rootReducer;</span><br></pre></td></tr></table></figure>
<p>store.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rootReducer <span class="keyword">from</span> <span class="string">&#x27;./rootReducer&#x27;</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(rootReducer);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">기존 state.count 에서</span><br><span class="line"> state.subscribers.count 로 변경 후</span><br><span class="line"> destructuriong 을 통해 &#123; subscribers &#125; 로 가져옴,</span><br><span class="line"> subscribers.count로 변경</span><br></pre></td></tr></table></figure>
<p>redux안에 export용 종합 action 파일 index.js 만들기</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; addSubscriber, removeSubscriber&#125; <span class="keyword">from</span> <span class="string">&#x27;./subscribers/actions&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; accView &#125; <span class="keyword">from</span> <span class="string">&#x27;./views/actions&#x27;</span></span><br></pre></td></tr></table></figure>
<p>… 작성중…</p>
]]></content>
      <categories>
        <category>library</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>알고리즘_기초_1</title>
    <url>/2021/02/06/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B8%B0%EC%B4%88-1/</url>
    <content><![CDATA[<p>컴퓨터 알고리즘이란 컴퓨터를 이용하여 문제를 해결하는 방법</p>
<a id="more"></a>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
</search>
